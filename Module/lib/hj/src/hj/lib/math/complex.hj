package hj.lib.math;

/*
 *
 * (C) Copyright Rice University 2009
 *
 *  This file is part of Hj Complex Library Test.
 *
 */
public class complex {

	public static final double PI2 = 2*StrictMath.PI;
	public static final double PIon2 = StrictMath.PI/2.0;
	public static final double PIon4 = StrictMath.PI/4.0;

	public static String toString(complex64 cx) {
		return "(" + real(cx) + "," + imag(cx) + ")";	
	}
	
	public static String toString(complex32 cx) {
		return "(" + real(cx) + "," + imag(cx) + ")";
	}

    // JG as per GCC C++
	public static double abs(complex64 cx) { 
		double 	   x,y,s;
	
		x = real(cx);
		y = imag(cx);
	
		s = Math.max(Math.abs(x),Math.abs(y));
		if (s==0.0) {
			return s;
		} else {
			x/=s;
			y/=s;
			return s * Math.sqrt(x*x+y*y); 
		}
    } 

	public static complex64 exp(complex64 cx) {
		// this is about 2x faster, dependent on unwrapping phase into [pi/4,-pi/4]
     	double phase,s,c=0;
        boolean cosNeg=false, sinNeg=false;     
        
        final double exp = Math.exp(real(cx));

        // crude hack to get phase into [0,2pi]. Purists, avert your gaze ;-)
        phase = Math.floor(imag(cx)/PI2);
        phase = imag(cx) - phase*PI2;

        if (phase>Math.PI) {
        	phase -= PI2; // in [-Pi,Pi]
        }
        
        if (phase<0)
          {
                phase =-phase;
                sinNeg = true;
          }
        // [0<=phase<=PI]
        if (phase>PIon2)
          {
                cosNeg=true;
                phase = Math.PI - phase;
          }
        // [0<=phase<=Pi/2]
        if (phase<PIon4)
          {
                // fast
                s = Math.sin(phase);
                c = Math.cos(phase);
          }
        else
          {
                phase = PIon2 - phase;
                s = Math.cos(phase);
                c = Math.sin(phase);
          }
        if (cosNeg) c = -c;
        if (sinNeg) s = -s;

        return (exp * c, exp*s);
	}
	
	public static complex64 sqrt(complex64 cx) {
    	double abs = abs(cx);
		double real = Math.sqrt((abs + real(cx)) / 2);
		double imag = imag(cx) /Math.sqrt(2 * (abs + real(cx)));
    	return (real, imag);     
    }	
}